import {
  ADD_PHOTOS, ADD_INFOS, ADD_MESSAGES, ADD_CLIENTS, INIT_DATA, REMOVE_PHOTO,
  syncAddedPhotoChild, syncRemovedPhotoChild,
  SYNC_ADDED_PHOTO_CHILD, SYNC_REMOVED_PHOTO_CHILD,
  syncAddedMessagesClientChild, SYNC_ADDED_MESSAGES_CLIENT_CHILD, 
  INIT_CLIENT_MESSAGES, syncAddedInfoChild, syncRemovedInfoChild,
  SYNC_ADDED_INFO_CHILD, SYNC_REMOVED_INFO_CHILD, MARK_CLIENT_PHOTO_READ,
  INCREMENT_TRAINER_PHOTO_NOTIFICATION, DECREMENT_TRAINER_PHOTO_NOTIFICATION,
} from '../constants/ActionTypes'
import {REHYDRATE} from 'redux-persist/constants'

import * as db from './firebaseCommands'
import { Image } from "react-native"
import {call, fork, put, select, take} from 'redux-saga/effects'
import { takeLatest } from 'redux-saga'
import Config from 'react-native-config'

import firebase from 'firebase'
import DeviceInfo from 'react-native-device-info'
import PushNotification from 'react-native-push-notification'

const turlHead = Config.AWS_CDN_THU_URL
const urlHead = Config.AWS_CDN_IMG_URL
const deviceId = DeviceInfo.getUniqueID()

const prefetchData = (cdnPath) => {
  return Image.prefetch(cdnPath)
    .then(() => {})
    .catch(error => {console.log(error + ' - ' + cdnPath)})
}

function* startClientDataPrefetch() {
  const {cdnPaths} = yield select(state => state.trainerReducer)
  for (let path in cdnPaths) {
    yield fork(prefetchData, cdnPaths[path])
  }
}

function* readClientPhotoFlow() {
  while (true) {
    const data = yield take(MARK_CLIENT_PHOTO_READ)
    const {path, id} = data
    firebase.database().ref(path).update({'notifyTrainer': false})
    yield put({type: DECREMENT_TRAINER_PHOTO_NOTIFICATION, databasePath: path, client: id})
  }
}

function* triggerGetMessagesClientChild() {
  while (true) {
    const { payload: { data } } = yield take(SYNC_ADDED_MESSAGES_CLIENT_CHILD)
    const messages = data.val()
    const mDeviceId  = messages.messageDeviceId
    const trainer = messages.trainer
    const flag = messages.clientRead
    const path = '/global/' + mDeviceId + '/photoData/' + messages.photo
    const file = turlHead + mDeviceId + '/' + messages.photo + '.jpg'
    yield put ({type: ADD_MESSAGES, messages, path})
    if (flag) {
      yield put({type: INCREMENT_TRAINER_PHOTO_NOTIFICATION, databasePath: path, client: mDeviceId})
      // PushNotification.localNotification({
      //   /* Android Only Properties */
      //   id: '0', // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
      //   ticker: "My Notification Ticker", // (optional)
      //   autoCancel: true, // (optional) default: true
      //   largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
      //   smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
      //   bigText: "My big text that will be shown when notification is expanded", // (optional) default: "message" prop
      //   subText: "This is a subText", // (optional) default: none
      //   color: "red", // (optional) default: system default
      //   vibrate: true, // (optional) default: true
      //   vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
      //   tag: 'some_tag', // (optional) add tag to message
      //   group: "group", // (optional) add group to message
      //   ongoing: false, // (optional) set whether this is an "ongoing" notification

      //   /* iOS only properties */
      //   alertAction: "view", // (optional) default: view
      //   category: '', // (optional) default: null
      //   userInfo: {}, // (optional) default: null (object containing additional notification data)

      //   /* iOS and Android properties */
      //   title: "Client Message", // (optional, for iOS this is only used in apple watch, the title will be the app name on other iOS devices)
      //   message: messages.message.text, // (required)
      //   playSound: true, // (optional) default: true
      //   soundName: 'default', // (optional) Sound to play when the notification is shown. Value of 'default' plays the default sound. It can be set to a custom sound such as 'android.resource://com.xyz/raw/my_sound'. It will look for the 'my_sound' audio file in 'res/raw' directory and play it. default: 'default' (default sound is played)
      //   number: 10, // (optional) Valid 32 bit integer specified as string. default: none (Cannot be zero)
      //   repeatType: 'hour', // (Android only) Repeating interval. Could be one of `week`, `day`, `hour`, `minute, `time`. If specified as time, it should be accompanied by one more parameter 'repeatTime` which should the number of milliseconds between each interval
      //   actions: '["Yes", "No"]',  // (Android only) See the doc for notification actions to know more
      // })
    }
    const prevMessages = yield select(state => state.chatReducer.messages)
    const count = yield select(state => state.chatReducer.count)
  }
}

function* syncClientChatData() {
  while (true) {
    const data = yield take (INIT_CLIENT_MESSAGES)
    const msgPath = data.path + '/messages'
    yield fork(db.sync, msgPath, {
      child_added: syncAddedMessagesClientChild
    })
  }
}

function* triggerGetPhotoChild() {
  const {databasePaths} = yield select(state => state.trainerReducer)
  while (true) {
    const { payload: { data } } = yield take(SYNC_ADDED_PHOTO_CHILD)
    if (data.val().visible) {
      const file = data.val()
      const fDeviceId = file.deviceId
      const databasePath = file.databasePath
      var child = {}
      child[fDeviceId] = file
      if (databasePaths.includes(databasePath) === false)
        yield put({type: ADD_PHOTOS, child, databasePath, fileName: file.fileName})
      const messageData = file.messages
      const path = file.databasePath
      for (var keys in messageData) {
        const messages = messageData[keys]
        yield put ({type: ADD_MESSAGES, messages, path})
      }
      yield put ({type: INIT_CLIENT_MESSAGES, path})
    }
  }
}

function* triggerRemPhotoChild() {
  while (true) {
    const { payload: { data } } = yield take(SYNC_REMOVED_PHOTO_CHILD)
    yield put({type: REMOVE_PHOTO, databasePath: data.val().databasePath})
  }
}

function* triggerGetInfoChild() {
  const {infoIds} = yield select(state => state.trainerReducer)
  while (true) {
    const { payload: { data } } = yield take(SYNC_ADDED_INFO_CHILD)
    const name = data.val().name
    const picture = data.val().picture
    const child = {name, picture}
    const id = data.val().deviceId
    const info = {id, child}
    if (infoIds.includes(id) === false)
      yield put({type: ADD_INFOS, child: info})
  }
}

function* triggerRemInfoChild() {
  while (true) {
    const { payload: { data } } = yield take(SYNC_REMOVED_INFO_CHILD)
    const child = data
  }
}

function* syncData() {
  let clients = yield select(state => state.trainerReducer.clients)
  for (let i = 0; i < clients.length; i++) {
    let path = '/global/' + clients[i]
    yield fork(db.sync, path + '/photoData', {
      child_added: syncAddedPhotoChild,
      child_removed: syncRemovedPhotoChild,
    })
    yield fork(db.sync, path + '/userInfo', {
      child_added: syncAddedInfoChild,
      child_removed: syncRemovedInfoChild,
    })
  }
}

export default function* rootSaga() {
  yield fork(takeLatest, [REHYDRATE, INIT_DATA], syncData)
  yield fork(takeLatest, [REHYDRATE, INIT_DATA], syncClientChatData)
  yield fork(takeLatest, [REHYDRATE, INIT_DATA], readClientPhotoFlow)
  yield fork(takeLatest, [REHYDRATE, INIT_DATA], triggerGetInfoChild)
  yield fork(takeLatest, [REHYDRATE, INIT_DATA], triggerRemInfoChild)
  yield fork(takeLatest, [REHYDRATE, INIT_DATA], triggerGetPhotoChild)
  yield fork(takeLatest, [REHYDRATE, INIT_DATA], triggerRemPhotoChild)
  yield fork(takeLatest, [REHYDRATE, INIT_DATA], startClientDataPrefetch)
  yield fork(takeLatest, [REHYDRATE, INIT_DATA], triggerGetMessagesClientChild)
}
